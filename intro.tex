\section{Introduction}

Cyber-physical systems (CPS) exhibit a number of characteristics that challenge current design paradigms and testing methods.  Key characteristics inherent to deployed systems include the need for reactive or real time processing; networks that inject stochastic delays and loss of reliability in communication; nodes with strongly heterogeneous processing platforms; and brittle user interfaces. Growing demand for distributed intelligence in CPS will increase the complexity of CPS software. These characteristics in turn influence the CPS design and design processes through layering and the refinement of abstractions. To manage design complexity, CPS design employs layering in multiple domains, e.g., computation, networking, and the modeling of the embedding physical system and the system's sensors and actuators. However, current layering approaches do not capture non-functional system properties essential to CPS, e.g., timing and energy use, that emerge via testing.  To manage design process complexity, iterative development is commonplace: while the long-term trend is refinement of abstract models, engineers often need to shift back and forth  between implementation-level models and more abstract models to gather new data, gain knowledge and insight, and optimize system performance.  The integration of effective testing into the design process will be central to the success of CPS in critical applications, but the question is how to do this.

The same multiplicity of layers also often applies to existing tests for CPS (and other embedded systems):  often components of a system, such as a file system or actuators, are tested by one set of engineers, and using completely different methods than are used to produce tests at the high level of either control software with humans-in-the-loop or autonomous control systems.  
The core functionality of a CPS is usually written in low-level, embedded
systems languages, such as C.  In the ideal case, such systems are developed using both
formal specification and verification and sophisticated automated
testing.  In some cases the formal specification is used to generate
executable tests to ensure the real system matches the formal models;
in other cases there is at least a very determined test generation
effort, including efforts to produce very high-coverage tests.  In
contrast, the user-centric or high-level autonomy aspects of a CPS are often developed in higher-level
languages, such as Java, and with a much more informal approach to
testing and verification.  Increasingly, mission and safety-critical low-level CPS elements
interact with user-centric systems, in order to allow users more
control.  Even when the behavior of each system, in isolation, is
valid, their composition may compromise either user experience or (in
the worst case) safety.

We propose a two-part solution to the problems of using testing to guide CPS design, and ensuring that completed CPS implementations have effectives tests that validate a system not only at each layer, but in terms of unexpected interactions between layers.  First, we propose the problem of automatically \emph{composing tests}, including heterogenous tests targeting different layers of a system.  Often there exist tests for behaviors at different levels of considerably value, but no way to effectively combine these tests.

Second, we propose the development of architectural models that facilitate such automated composition and explicitly represent the domain of a design, and the level of abstraction (layer) in that domain.  The key point is to construct test architectures  that enable the ability to employ constituent CPS models for different domains at diverse levels of abstraction in a plug-n-play manner.

As an example of the practical aims of our proposed approach, it would be helpful to run the low-level tests in one domain in the context of other domains expressed using high-level models. For example, a unit-level test of implementation-level code running on a target sensor-actuator node might be connected with a meteorological model running in the cloud that drives an emulated sensor, and, through a simple packet-layer communication model, to a high-level control system model running in real-time on an engineer's workstation that in turn drives an actuator via commands sent through the communication model. As another example, existing production-level, server-based control code may need to be integrated with a new actuating subsystem. Here, functional tests could be performed using a sequence of models (of increasing refinement) prior to integration of the target actuating hardware.
