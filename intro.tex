\section{Introduction}

Cyber-physical systems exhibit a number of characteristics that challenge current design paradigms.  We distinguish here between three types of characteristics. Key characteristics inherent to deployed systems include the need for reactive or real time processing; networks that inject stochastic delays and loss of reliability in communication; nodes with strongly heterogeneous processing platforms; and brittle interfaces. Growing demand for distributed intelligence in CPS will increase the complexity of CPS software. These characteristics in turn influence CPS design and design processes through layering and the refinement of abstractions. To manage design complexity, CPS design employs layering in multiple domains, e.g., computation, networking, and the modeling of the embedding physical system and the system's sensors and actuators. However, current layered do not capture non-functional system properties essential to CPS, e.g., timing and energy use, that emerge via testing.  To manage design process complexity, iterative development is commonplace: while the long-term trend is refinement of abstract models, engineers would like to shuffle between implementation-level models and more abstract models to gather new data, gain knowledge and insight, and optimize system performance. 

The integration of testing into the design process will be central to the success of CPS in complexity-demanding applications, but the question is how to do this. We propose an architectural model of testing for CPS that enables combining tests in two dimensions: the domain, and the level of abstraction (layer) in that domain.  The key point is to construct test architectures  that enable the ability to employ constituent CPS models for different domains at diverse levels of abstraction in a plug-n-play manner.

As just one case, it would be helpful to run the low-level tests in one domain in the context of other domains expressed using high-level models. For example, a unit-level test of implementation-level code running on a target sensor-actuator node might be connected with a meteorological model running in the cloud that drives an emulated sensor, and, through a simple packet-layer communication model, to a high-level control system model running in real-time on an engineer's workstation that in turn drives an actuator via commands sent through the communication model. As another example, existing production-level, server-based control code may need to be integrated with a new actuating subsystem. Here, functional tests could be performed using a sequence of models (of increasing refinement) prior to integration of the target actuating hardware.
